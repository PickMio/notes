1. c++中的特殊成员变量:
	- 引用
	- 常量
	- 静态变量
	- 静态常量(整型)
	- 静态常量(非整型)

	
			常量和引用,必须通过参数列表进行初始化.静态成员
			变量在类外初始化且不能带有static关键字.

	参考代码:
	
		#include<iostream>
		using namespace std;
		class BClass{
		public:
			BClass():i(1),ci(2),ri(i){}
		private:
			int i;			//普通成员变量
			const int ci;   //常量....
			int &ri;		//引用....
			static int si;	//静态....
			//static int si2=100;//错误,只有静态常量成员变量才可以这样初始化
			int const &ps4 = 32;//这个是对的 
			static const int csi; //静态常量成员变量
			static const int cs2 = 100;//静态常量成员变量的初始化
	
			static const double csd;//静态常量成员变量
			//static const double csd2 = 99.3;//错误,只有静态常量整型数据成员才可以在类中初始化.
		}
		
		int BClass::si = 0;// 静态成员变量初始化
		const int BClass::csi = 1;//静态常量成员变量初始化(整型)
		const double BClass::csd = 99.9;//静态常量成员变量初始化(非整型)

	

2. 声明引用时,必须同时对其进行初始化,引用声明完毕后,相当于变量有两个名称,即目标原名称和引用名.声明一个引用,不是新定义了一个变量,它只是表示该引用别名是目标变量的一个别名,且不能再把该引用名作为其他变量的别名.本身不是一种数据类型,引用本身不占存储单元,对引用求地址,就是对目标变量求地址,求sizeof就是求目标变量的size.
3. 不能建立引用的引用,也不能建立指向引用的指针.因为引用不是一种数据类型.

		int n;
		int &&r = n;//错误,编译系统把 int &看成一体, &r看成一体,即建立了引用的引用,引用的对象应当是某种数据类型的变量.从右值引用来看,不能将一个右值引用绑定到一个左值上. 
		int &&rr2 = n * 128; //正确,将rr2绑定到乘法结果上. //cpp 11
		int&*p = n; //错误,*p看成一体,建立了指向引用的指针 

		int *p;
		int *&q = p;//正确,int* 整体, &q整体,建立指针p的引用.

5. 引用和多态,引用时除指针外另一个可以产生多态效果的手段,一个基类的引用可以指向它的派生类实例.

		class A;
		class B:public A{};
		B b;
		A &Ref = b;
6. c++中成员变量是引用.引用类型成员变量的初始化://为什么这么做不明
	- 不能直接在构造函数里初始化，必须用到初始化列表，且形参也必须是引用类型。
	- 凡是有引用类型的成员变量的类，不能有缺省构造函数。原因是**引用类型的成员变量必须在类构造时进行初始化**。
	- 如果两个类要对第三个类的数据进行共享处理，可以考虑把第三个类作为这两个类的引用类型的成员变量。